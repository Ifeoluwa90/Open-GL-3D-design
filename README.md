# 3D Scene Project for Computational Graphics and Visualization

## Project Overview

This repository contains my final project for a Computational Graphics and Visualization course. The project demonstrates the application of OpenGL and C++ to create an interactive 3D scene based on a 2D reference image of an autumn still life arrangement. The implementation features various 3D objects with textures, lighting effects, and camera navigation capabilities.

# 3D Scene Project for Computational Graphics and Visualization

## Project Overview

This repository contains my final project for a Computational Graphics and Visualization course. The project demonstrates the application of OpenGL and C++ to create an interactive 3D scene based on a 2D reference image of an autumn still life arrangement. The implementation features various 3D objects with textures, lighting effects, and camera navigation capabilities.

![[Project Preview Image](https://github.com/Ifeoluwa90/Open-GL-3D-design/blob/main/Milestone1.jpg)](preview.png)
## Repository Contents

* **3D Scene Application** - A C++ application built with OpenGL that renders the 3D scene
* **Design Decisions Document** - A comprehensive explanation of the implementation choices
* **Source Code** - All C++ files including ShaderManager, SceneManager, ViewManager, and ShapeMeshes

## Technologies Used

* C++
* OpenGL 3+
* GLFW for window management and input handling
* GLM for mathematics operations
* Various shader implementations (GLSL)

## Features

* **Multiple 3D Objects**: Vase with flowers, pumpkin, candle holders, and a book
* **Texturing**: UV mapping with multiple textures applied to different objects
* **Lighting**: Multiple light sources with different properties using the Phong shading model
* **Interactive Camera**: WASD/QE movement with mouse controls for orientation
* **Projection Modes**: Toggle between perspective and orthographic views

## Personal Reflection

### How I Approach Designing Software

Working on this 3D scene project helped me develop several new design skills, particularly in the realm of translating real-world objects into simplified 3D representations. I learned to analyze complex shapes and break them down into combinations of primitive 3D forms - a skill that transfers well to many areas of software design.

My design process involved:
1. Analyzing the reference image and identifying key objects
2. Sketching approximate representations using basic shapes
3. Planning the hierarchical structure of objects
4. Iteratively refining each object's appearance

This methodical approach to breaking down complex problems into manageable components is a tactic I'll apply to future software design challenges, regardless of domain. It reinforces the importance of planning before implementation and the value of starting with a minimal viable solution that can be refined over time.

### How I Approach Developing Programs

This project introduced me to several new development strategies. I implemented shader-based rendering techniques, learned to work with vertex buffer objects, and gained experience with 3D mathematics for transformations and lighting calculations. Most significantly, I adopted a component-based architecture that separated concerns between scene management, view control, and mesh generation.

Iteration was fundamental to my development process. I began with simple shapes and basic navigation, then systematically added features while continuously testing and refining. Each milestone introduced new complexity while building on previous work, which helped manage the growing codebase effectively.

My approach to development evolved throughout the project from basic implementation to more sophisticated techniques. Initially, I focused on getting something visible on screen, but as the project progressed, I became more attentive to code organization, performance considerations, and reusability. The modular structure I developed by the end will serve as a template for future graphics programming work.

### How Computer Science Helps Me Reach My Goals

Computational graphics and visualization have expanded my understanding of mathematics, physics, and software engineering principles. The blend of linear algebra, geometric transformations, and light physics provides a foundation that extends beyond graphics programming into areas like data visualization, simulation, and user interface design.

Professionally, these skills open opportunities in game development, simulation software, data visualization tools, and interactive media. The ability to create visual representations of complex data and systems is increasingly valuable across industries, from healthcare to finance. Even in roles not directly related to graphics, the problem-solving approaches and attention to performance optimization developed through this project will enhance my ability to create efficient, well-structured software.

This project has reinforced my passion for creating visual experiences through code and has given me confidence in tackling complex technical challenges through systematic decomposition and iterative development.

## Installation and Running

### Prerequisites
* C++ compiler with C++11 support
* OpenGL 3.3+ compatible graphics card
* GLFW and GLEW libraries

### Building
1. Clone this repository
2. Ensure all dependencies are installed
3. Build using your preferred build system (Visual Studio solution included)

### Controls
* **W/A/S/D**: Forward/Left/Backward/Right movement
* **Q/E**: Up/Down movement
* **Mouse**: Look around
* **Mouse Scroll**: Adjust movement speed
* **P/O**: Toggle between perspective and orthographic view

## Acknowledgments

* SNHU CS-330 course materials and instructor guidance
* Various OpenGL tutorials and documentation resources

## Repository Contents

* **3D Scene Application** - A C++ application built with OpenGL that renders the 3D scene
* **Design Decisions Document** - A comprehensive explanation of the implementation choices
* **Source Code** - All C++ files including ShaderManager, SceneManager, ViewManager, and ShapeMeshes

## Technologies Used

* C++
* OpenGL 3+
* GLFW for window management and input handling
* GLM for mathematics operations
* Various shader implementations (GLSL)

## Features

* **Multiple 3D Objects**: Vase with flowers, pumpkin, candle holders, and a book
* **Texturing**: UV mapping with multiple textures applied to different objects
* **Lighting**: Multiple light sources with different properties using the Phong shading model
* **Interactive Camera**: WASD/QE movement with mouse controls for orientation
* **Projection Modes**: Toggle between perspective and orthographic views

## Personal Reflection

### How I Approach Designing Software

Working on this 3D scene project helped me develop several new design skills, particularly in the realm of translating real-world objects into simplified 3D representations. I learned to analyze complex shapes and break them down into combinations of primitive 3D forms - a skill that transfers well to many areas of software design.

My design process involved:
1. Analyzing the reference image and identifying key objects
2. Sketching approximate representations using basic shapes
3. Planning the hierarchical structure of objects
4. Iteratively refining each object's appearance

This methodical approach to breaking down complex problems into manageable components is a tactic I'll apply to future software design challenges, regardless of domain. It reinforces the importance of planning before implementation and the value of starting with a minimal viable solution that can be refined over time.

### How I Approach Developing Programs

This project introduced me to several new development strategies. I implemented shader-based rendering techniques, learned to work with vertex buffer objects, and gained experience with 3D mathematics for transformations and lighting calculations. Most significantly, I adopted a component-based architecture that separated concerns between scene management, view control, and mesh generation.

Iteration was fundamental to my development process. I began with simple shapes and basic navigation, then systematically added features while continuously testing and refining. Each milestone introduced new complexity while building on previous work, which helped manage the growing codebase effectively.

My approach to development evolved throughout the project from basic implementation to more sophisticated techniques. Initially, I focused on getting something visible on screen, but as the project progressed, I became more attentive to code organization, performance considerations, and reusability. The modular structure I developed by the end will serve as a template for future graphics programming work.

### How Computer Science Helps Me Reach My Goals

Computational graphics and visualization have expanded my understanding of mathematics, physics, and software engineering principles. The blend of linear algebra, geometric transformations, and light physics provides a foundation that extends beyond graphics programming into areas like data visualization, simulation, and user interface design.

Professionally, these skills open opportunities in game development, simulation software, data visualization tools, and interactive media. The ability to create visual representations of complex data and systems is increasingly valuable across industries, from healthcare to finance. Even in roles not directly related to graphics, the problem-solving approaches and attention to performance optimization developed through this project will enhance my ability to create efficient, well-structured software.

This project has reinforced my passion for creating visual experiences through code and has given me confidence in tackling complex technical challenges through systematic decomposition and iterative development.

## Installation and Running

### Prerequisites
* C++ compiler with C++11 support
* OpenGL 3.3+ compatible graphics card
* GLFW and GLEW libraries

### Building
1. Clone this repository
2. Ensure all dependencies are installed
3. Build using your preferred build system (Visual Studio solution included)

### Controls
* **W/A/S/D**: Forward/Left/Backward/Right movement
* **Q/E**: Up/Down movement
* **Mouse**: Look around
* **Mouse Scroll**: Adjust movement speed
* **P/O**: Toggle between perspective and orthographic view

## Acknowledgments

* SNHU CS-330 course materials and instructor guidance
* Various OpenGL tutorials and documentation resources
